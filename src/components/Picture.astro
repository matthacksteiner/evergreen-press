---
/**
 * Picture Component
 *
 * Renders a responsive picture element with various image sizes and formats.
 * Supports both production (with image processing) and development environments.
 * Prevents layout shifts by maintaining proper aspect ratios before image loads.
 *
 * @component
 * @example
 * ```astro
 * <Picture
 *   src="/images/example.jpg"
 *   urlFocus="/images/example-focus.jpg"
 *   urlFocusMobile="/images/example-focus-mobile.jpg"
 *   width={1200}
 *   height={800}
 *   name="example-image"
 *   ratioMobile="1/1"
 *   ratioDesktop="16/9"
 *   span="6"
 *   thumbhash="data:image/png;base64,..."
 * />
 * ```
 *
 * Features:
 * - Responsive image loading with different sources for mobile and desktop
 * - Automatic size calculations based on grid system
 * - Optional thumbhash placeholder for improved loading experience
 * - Layout shift prevention using CSS aspect ratio
 * - Support for image zooming functionality
 *
 * The component preserves aspect ratios during loading to prevent CLS (Cumulative Layout Shift).
 * When thumbhash is provided, it displays a blurred placeholder until the image loads.
 */

const isProd = import.meta.env.PROD;
const netlifyDev = import.meta.env.NETLIFY_DEV;
const netlifyUrl = import.meta.env.NETLIFY_URL;

interface Props {
	// Required props
	src: string;
	urlFocus: string;
	urlFocusMobile: string;
	width: number;
	height: number;
	name: string;
	ratioMobile: string;
	ratioDesktop: string;
	span: string;

	// Optional props with defaults
	alt?: string;
	position?: string;
	id?: string;
	class?: string;
	loading?: 'eager' | 'lazy';
	backgroundContainer?: 'container' | 'full';
	gridMarginDesktop?: number;
	gridMarginMobile?: number;
	gridGapDesktop?: number;
	gridGapMobile?: number;

	// Optional features
	thumbhash?: string;
	dataZoomable?: boolean;
	dataZoomSrc?: string;
	aboveFold?: boolean;
	isFirstSlide?: boolean;
}

const {
	src,
	urlFocus,
	urlFocusMobile,
	width,
	height,
	name,
	ratioMobile,
	ratioDesktop,
	span,
	// Optional props with defaults
	alt,
	position = 'center',
	id,
	class: className,
	loading = 'lazy',
	backgroundContainer = 'container',
	gridMarginDesktop = 24,
	gridMarginMobile = 16,
	gridGapDesktop = 24,
	gridGapMobile = 16,
	// Optional features
	thumbhash,
	dataZoomable,
	aboveFold,
	isFirstSlide,
} = Astro.props;
// Input validation
if (
	!src ||
	!width ||
	!height ||
	!name ||
	!ratioMobile ||
	!ratioDesktop ||
	!span
) {
	throw new Error('Missing required props in Picture component');
}

// Determine fetchpriority based on aboveFold and isFirstSlide
// If it's above fold and it's the first slide, it gets high priority
const fetchPriority =
	aboveFold && (isFirstSlide || isFirstSlide === undefined) ? 'high' : 'low';

const validateRatio = (ratio: string) => {
	if (ratio !== 'original' && !ratio.match(/^\d+\/\d+$/)) {
		throw new Error(
			`Invalid ratio format: ${ratio}. Must be either 'original' or 'number/number'`
		);
	}
};

validateRatio(ratioMobile);
validateRatio(ratioDesktop);

const baseUrl = isProd
	? netlifyUrl
	: netlifyDev
	? 'http://localhost:8888'
	: netlifyUrl;

const getRatio = (ratio: string, width: number, height: number): number => {
	if (!ratio) {
		console.warn('Ratio is undefined, using default 1/1');
		return 1; // default square ratio
	}

	const [numerator, denominator] =
		ratio === 'original' ? [width, height] : ratio.split('/');
	return Number(numerator) / Number(denominator);
};

const ratioDesktopValue = getRatio(ratioDesktop, width, height);
const ratioMobileValue = getRatio(ratioMobile, width, height);

const sourceMobile = ratioMobile === 'original' ? src : urlFocusMobile;
const sourceDesktop = ratioDesktop === 'original' ? src : urlFocus;

const gridMarginTotal = 2;
const gridMarginDesktopTotal = gridMarginDesktop * gridMarginTotal;
const gridMarginMobileTotal = gridMarginMobile * gridMarginTotal;

// Calculate column width accounting for grid gaps
const calculateColumnWidth = (
	containerWidth: number,
	columns: number,
	gridGap: number
): number => {
	const totalGapSpace = gridGap * (columns - 1);
	const availableSpace = containerWidth - totalGapSpace;
	return availableSpace / columns;
};

// Calculate total width for a span of columns including gaps
const imageWidth = (
	containerWidth: number,
	columns: number,
	span: string,
	gridGap: number
): number => {
	const columnWidth = calculateColumnWidth(containerWidth, columns, gridGap);
	return Math.round(columnWidth * Number(span) + gridGap * (Number(span) - 1));
};

const imageHeight = (imageWidth: number, ratio: number): number =>
	Math.round(imageWidth / ratio);

// Desktop calculations
const desktopColumns = 12;
const containerWidthDesktop =
	backgroundContainer === 'container' ? 1920 - gridMarginDesktopTotal : 2560;
const imageWidthDesktop = imageWidth(
	containerWidthDesktop,
	desktopColumns,
	span,
	gridGapDesktop
);

// Mobile calculations
const mobileColumns = 6;
const containerWidthMobile = 390 - gridMarginMobileTotal;
const imageWidthMobile = imageWidth(
	containerWidthMobile,
	mobileColumns,
	span,
	gridGapMobile
);

// Other width calculations
const imageWidthDesktop1280 = imageWidth(
	1280,
	desktopColumns,
	span,
	gridGapDesktop
);
const imageWidthDesktop1920 = imageWidth(
	1920 - gridMarginDesktopTotal,
	desktopColumns,
	span,
	gridGapDesktop
);

const imageHeightMobile = imageHeight(imageWidthMobile, ratioMobileValue);
const imageHeightDesktop = imageHeight(imageWidthDesktop, ratioDesktopValue);
const imageHeightDesktop1280 = imageHeight(
	imageWidthDesktop1280,
	ratioDesktopValue
);
const imageHeightDesktop1920 = imageHeight(
	imageWidthDesktop1920,
	ratioDesktopValue
);

const altFallback = name
	? name
			.replace(/[-_]/g, ' ')
			.replace(/[^\w\s]/g, '')
			.replace(/\b\w/g, (char) => char.toUpperCase())
	: 'Image';

const generateSrcSet = (
	source: string,
	width: number,
	height: number
): string => {
	const srcSetValues = [1, 2, 3].map((value) => {
		const multipliedWidth = width * value;
		const multipliedHeight = height * value;
		return `${baseUrl}/.netlify/images?url=${source}&w=${multipliedWidth}&h=${multipliedHeight}&fit=cover&fm=avif&q=70 ${value}x`;
	});

	return srcSetValues.join(', ');
};

const generateImgSrc = (
	source: string,
	width: number,
	height: number
): string => {
	return `${baseUrl}/.netlify/images?url=${source}&w=${width}&h=${height}&fit=cover&fm=avif&q=70`;
};
---

{
	isProd || netlifyDev ? (
		<div
			class="picture-container"
			style={`--ratio-mobile: ${ratioMobileValue}; --ratio-desktop: ${ratioDesktopValue};`}
		>
			{thumbhash && (
				<div class="thumbhash" style={`background-image: url(${thumbhash});`} />
			)}
			<picture>
				<source
					srcset={generateSrcSet(
						sourceMobile,
						imageWidthMobile,
						imageHeightMobile
					)}
					media="(max-width: 768px)"
				/>
				<source
					srcset={generateSrcSet(
						sourceDesktop,
						imageWidthDesktop1280,
						imageHeightDesktop1280
					)}
					media="(min-width: 769px) and (max-width: 1280px)"
				/>
				<source
					srcset={generateSrcSet(
						sourceDesktop,
						imageWidthDesktop1920,
						imageHeightDesktop1920
					)}
					media="(min-width: 1281px) and (max-width: 1920px)"
				/>
				<source
					srcset={generateSrcSet(
						sourceDesktop,
						imageWidthDesktop,
						imageHeightDesktop
					)}
					media="(min-width: 1921px)"
				/>
				<source
					type="image/avif"
					srcset={generateSrcSet(
						sourceDesktop,
						imageWidthDesktop,
						imageHeightDesktop
					)}
				/>
				<source
					type="image/webp"
					srcset={generateSrcSet(
						sourceDesktop,
						imageWidthDesktop,
						imageHeightDesktop
					)}
				/>
				<source
					type="image/jpeg"
					srcset={generateSrcSet(
						sourceDesktop,
						imageWidthDesktop,
						imageHeightDesktop
					)}
				/>
				<img
					src={generateImgSrc(
						sourceDesktop,
						imageWidthDesktop,
						imageHeightDesktop
					)}
					width={imageWidthDesktop}
					height={imageHeightDesktop}
					alt={alt || altFallback}
					loading={aboveFold ? undefined : loading}
					id={id}
					data-zoomable={dataZoomable}
					data-zoom-src={
						dataZoomable
							? generateImgSrc(
									sourceDesktop,
									imageWidthDesktop * 2,
									imageHeightDesktop * 2
							  )
							: undefined
					}
					class:list={[className]}
					decoding="async"
					fetchpriority={fetchPriority}
				/>
			</picture>
		</div>
	) : (
		<div
			class="picture-container"
			style={`--ratio-mobile: ${ratioMobileValue}; --ratio-desktop: ${ratioDesktopValue};`}
		>
			{thumbhash && (
				<div class="thumbhash" style={`background-image: url(${thumbhash});`} />
			)}
			<picture>
				<source srcset={sourceMobile} media="(max-width: 768px)" />
				<source srcset={sourceDesktop} media="(min-width: 769px)" />
				<source type="image/avif" srcset={sourceDesktop} />
				<source type="image/webp" srcset={sourceDesktop} />
				<source type="image/jpeg" srcset={sourceDesktop} />
				<img
					src={sourceDesktop}
					width={imageWidthDesktop}
					height={imageHeightDesktop}
					alt={alt || altFallback}
					loading={aboveFold ? undefined : loading}
					id={id}
					data-zoomable={dataZoomable}
					data-zoom-src={dataZoomable ? sourceDesktop : undefined}
					class={className}
					decoding="async"
					fetchpriority={fetchPriority}
				/>
			</picture>
		</div>
	)
}

<style>
	.picture-container {
		@apply relative block w-full;
	}

	/* Apply aspect ratio based on screen size */
	.picture-container::before {
		@apply block w-full content-[''];
	}

	/* Mobile aspect ratio */
	@media (max-width: 768px) {
		.picture-container::before {
			padding-top: calc(1 / var(--ratio-mobile) * 100%);
		}
	}

	/* Desktop aspect ratio */
	@media (min-width: 769px) {
		.picture-container::before {
			padding-top: calc(1 / var(--ratio-desktop) * 100%);
		}
	}

	.thumbhash {
		@apply absolute inset-0 -z-10 bg-cover bg-center;
	}

	picture {
		@apply block;
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
	}

	picture img {
		@apply block h-full w-full object-cover;
	}
</style>
