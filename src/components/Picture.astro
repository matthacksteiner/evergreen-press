---
/**
 * Picture Component
 *
 * A responsive image component that handles:
 * - Optimal image loading for different screen sizes
 * - Prevents layout shifts using aspect ratio
 * - Supports multiple image formats and resolutions
 * - Works in both production and development environments
 *
 * @component
 * @example
 * ```astro
 * <Picture
 *   src="/images/example.jpg"          // Base image path
 *   urlFocus="/images/example-focus.jpg"    // Desktop focal point
 *   urlFocusMobile="/images/example-focus-mobile.jpg"  // Mobile focal point
 *   width={1200}                       // Original image width
 *   height={800}                       // Original image height
 *   name="example-image"               // Image name (used for alt text)
 *   ratioMobile="1/1"                  // Mobile aspect ratio
 *   ratioDesktop="16/9"                // Desktop aspect ratio
 *   span="6"                           // Grid columns to span
 *   thumbhash="data:image/png;base64,..." // Optional blur placeholder
 * />
 * ```
 *
 * ## Key Features
 *
 * - Responsive sizing: Automatically calculates image dimensions based on grid system
 * - Aspect ratios: Uses different ratios for mobile/desktop with smooth transitions
 * - Performance optimized: Supports lazy loading, fetchpriority, and decoding attributes
 * - Low CLS: Maintains aspect ratio placeholders during image load
 * - Enhanced UX: Optional thumbhash blurred placeholders while loading
 * - Zoom support: Optional zoomable images
 * - Production ready: Handles image processing in production via Netlify Image API
 */

import type { ImageProps } from '@types';
import { screens } from '@config/screens';
import { getAltFallback } from '@lib/helpers';

// --------------------------------------
// Environment Configuration
// --------------------------------------
const isProduction = import.meta.env.PROD;
const isNetlify = Boolean(import.meta.env.NETLIFY);
const netlifyUrl = import.meta.env.NETLIFY_URL;
const baseUrl = isProduction
	? netlifyUrl
	: isNetlify
	? 'http://localhost:8888'
	: netlifyUrl;

// Should we use Netlify Image processing?
const useNetlifyImageProcessing = isProduction || isNetlify;

// --------------------------------------
// Layout Constants
// --------------------------------------
const scrollbarWidth = 17;
const maxContainerWidth = 1920;

// --------------------------------------
// Responsive Breakpoints Configuration
// --------------------------------------
// Process screen sizes to create responsive breakpoints
const breakpoints = Object.entries(screens)
	.map(([key, value]) => ({
		key,
		value: parseInt(value.replace('px', '')),
	}))
	.sort((a, b) => a.value - b.value);

// Create screen ranges for media queries
const screenRanges = breakpoints.map((breakpoint, index) => {
	const nextBreakpoint = breakpoints[index + 1];

	if (index === 0) {
		// First breakpoint (mobile)
		return {
			key: breakpoint.key,
			mediaQuery: `(max-width: ${breakpoint.value}px)`,
			maxWidth: breakpoint.value,
		};
	} else if (!nextBreakpoint) {
		// Last breakpoint (largest screens)
		return {
			key: breakpoint.key,
			mediaQuery: `(min-width: ${breakpoint.value + 1}px)`,
			maxWidth: breakpoint.value * 1.5, // Extra size for largest screens
		};
	} else {
		// Middle breakpoints
		return {
			key: breakpoint.key,
			mediaQuery: `(min-width: ${breakpoint.value + 1}px) and (max-width: ${
				nextBreakpoint.value
			}px)`,
			maxWidth: nextBreakpoint.value,
		};
	}
});

// Map each breakpoint to its max container width (same as the screen value)
const maxContainerWidths = Object.fromEntries(
	Object.entries(screens).map(([key, value]) => [
		key,
		parseInt(value.replace('px', '')),
	])
);

interface Props extends ImageProps {
	// Additional props specific to Picture component
	urlFocus: string;
	urlFocusMobile: string;
	name: string;
	ratioMobile: string;
	ratioDesktop: string;
	span: string;
	position?: string;
	backgroundContainer?: 'container' | 'full';
	gridMarginDesktop?: number;
	gridMarginMobile?: number;
	gridGapDesktop?: number;
	gridGapMobile?: number;
	thumbhash?: string;
	dataZoomable?: boolean;
	dataZoomSrc?: string;
	aboveFold?: boolean;
	isFirstSlide?: boolean;
}

const {
	src,
	urlFocus,
	urlFocusMobile,
	width,
	height,
	name,
	ratioMobile,
	ratioDesktop,
	span,
	// Optional props with defaults
	alt,
	position = 'center',
	id,
	class: className,
	loading = 'lazy',
	backgroundContainer = 'container',
	gridMarginDesktop = 24,
	gridMarginMobile = 16,
	gridGapDesktop = 24,
	gridGapMobile = 16,
	// Optional features
	thumbhash,
	dataZoomable,
	aboveFold,
	isFirstSlide,
} = Astro.props;

// Input validation
if (
	!src ||
	!width ||
	!height ||
	!name ||
	!ratioMobile ||
	!ratioDesktop ||
	!span
) {
	throw new Error('Missing required props in Picture component');
}

// --------------------------------------
// Utility Functions
// --------------------------------------
function validateRatio(ratio: string) {
	if (ratio !== 'original' && !ratio.match(/^\d+\/\d+$/)) {
		throw new Error(
			`Invalid ratio format: ${ratio}. Must be either 'original' or 'number/number'`
		);
	}
}

function getRatio(ratio: string, width: number, height: number): number {
	if (!ratio) {
		console.warn('Ratio is undefined, using default 1/1');
		return 1; // default square ratio
	}

	const [numerator, denominator] =
		ratio === 'original' ? [width, height] : ratio.split('/');
	return Number(numerator) / Number(denominator);
}

function calculateColumnWidth(
	containerWidth: number,
	columns: number,
	gridGap: number
): number {
	const totalGapSpace = gridGap * (columns - 1);
	const availableSpace = containerWidth - totalGapSpace;
	return availableSpace / columns;
}

function calculateImageWidth(
	containerWidth: number,
	columns: number,
	span: string,
	gridGap: number
): number {
	const columnWidth = calculateColumnWidth(containerWidth, columns, gridGap);
	return Math.round(columnWidth * Number(span) + gridGap * (Number(span) - 1));
}

function calculateImageHeight(imageWidth: number, ratio: number): number {
	return Math.round(imageWidth / ratio);
}

function getContainerWidth(
	screenRange: (typeof screenRanges)[0],
	isMobile: boolean,
	gridMarginTotal: number
) {
	let containerWidth = screenRange.maxWidth - scrollbarWidth;
	const maxWidthForBreakpoint =
		maxContainerWidths[screenRange.key] || maxContainerWidth;
	if (backgroundContainer === 'container' && !isMobile) {
		containerWidth =
			Math.min(containerWidth, maxWidthForBreakpoint) - gridMarginTotal;
	}
	return containerWidth;
}

// --------------------------------------
// Image URL Generation - Production
// --------------------------------------
function createNetlifyImageUrl(
	source: string,
	width: number,
	height: number
): string {
	return `${baseUrl}/.netlify/images?url=${source}&w=${width}&h=${height}&fit=cover&fm=avif&q=70`;
}

function createProductionSrcSet(
	source: string,
	screenRange: (typeof screenRanges)[0],
	isMobile: boolean
): string {
	const columns = isMobile ? 6 : 12;
	const gridGap = isMobile ? gridGapMobile : gridGapDesktop;
	const gridMargin = isMobile ? gridMarginMobileTotal : gridMarginDesktopTotal;
	const containerWidth = getContainerWidth(screenRange, isMobile, gridMargin);
	const ratio = isMobile ? ratioMobileValue : ratioDesktopValue;

	return [1, 2, 3]
		.map((dpr) => {
			const dprMaxWidth = screenRange.maxWidth * dpr;
			const imgWidth = Math.min(
				calculateImageWidth(containerWidth, columns, span, gridGap) * dpr,
				dprMaxWidth
			);
			const imgHeight = calculateImageHeight(imgWidth, ratio);
			return `${createNetlifyImageUrl(source, imgWidth, imgHeight)} ${dpr}x`;
		})
		.join(', ');
}

function createProductionImageSrc(
	source: string,
	screenRange: (typeof screenRanges)[0],
	isMobile: boolean
): string {
	const columns = isMobile ? 6 : 12;
	const gridGap = isMobile ? gridGapMobile : gridGapDesktop;
	const gridMargin = isMobile ? gridMarginMobileTotal : gridMarginDesktopTotal;
	const containerWidth = getContainerWidth(screenRange, isMobile, gridMargin);
	const ratio = isMobile ? ratioMobileValue : ratioDesktopValue;

	// Use a reasonable default DPR of 2 for the fallback image
	// (srcset will handle actual DPR-specific images)
	const dpr = 2;
	const dprMaxWidth = screenRange.maxWidth * dpr;

	// Calculate width and apply DPR cap
	const calculatedWidth = calculateImageWidth(
		containerWidth,
		columns,
		span,
		gridGap
	);
	const width = Math.min(calculatedWidth, dprMaxWidth);
	const height = calculateImageHeight(width, ratio);

	return createNetlifyImageUrl(source, width, height);
}

// --------------------------------------
// Content Preparation
// --------------------------------------
// Validate ratios
validateRatio(ratioMobile);
validateRatio(ratioDesktop);

// Process aspect ratios
const ratioDesktopValue = getRatio(ratioDesktop, width, height);
const ratioMobileValue = getRatio(ratioMobile, width, height);

// Determine image sources based on ratios
const sourceMobile = ratioMobile === 'original' ? src : urlFocusMobile;
const sourceDesktop = ratioDesktop === 'original' ? src : urlFocus;

// Calculate grid margins
const gridMarginTotal = 2;
const gridMarginDesktopTotal = gridMarginDesktop * gridMarginTotal;
const gridMarginMobileTotal = gridMarginMobile * gridMarginTotal;

// Determine fetch priority for performance
const fetchPriority = aboveFold
	? isFirstSlide || isFirstSlide === undefined
		? 'high'
		: 'low'
	: undefined;

// Calculate final image dimensions for markup
function getCalculatedWidth() {
	const lastScreenRange = screenRanges[screenRanges.length - 1];
	const maxWidthForBreakpoint =
		maxContainerWidths[lastScreenRange.key] || maxContainerWidth;
	let containerWidth;

	if (backgroundContainer === 'container') {
		containerWidth =
			Math.min(lastScreenRange.maxWidth, maxWidthForBreakpoint) -
			scrollbarWidth -
			gridMarginDesktopTotal;
	} else {
		containerWidth = Math.min(2560, maxWidthForBreakpoint * 2) - scrollbarWidth;
	}

	// Calculate width and apply DPR cap for largest displays
	const calculatedWidth = calculateImageWidth(
		containerWidth,
		12,
		span,
		gridGapDesktop
	);
	const defaultDpr = 2; // Reasonable default for markup
	const dprMaxWidth = lastScreenRange.maxWidth * defaultDpr;

	return Math.min(calculatedWidth, dprMaxWidth);
}

const imgWidth = getCalculatedWidth();
const imgHeight = calculateImageHeight(imgWidth, ratioDesktopValue);
---

<div
	class="picture-container"
	style={`--ratio-mobile: ${ratioMobileValue}; --ratio-desktop: ${ratioDesktopValue};`}
>
	{
		thumbhash && (
			<div class="thumbhash" style={`background-image: url(${thumbhash});`} />
		)
	}
	<picture>
		{
			screenRanges.map((range, index) => {
				const source = index === 0 ? sourceMobile : sourceDesktop;
				const isMobile = index === 0;

				return (
					<source
						srcset={
							useNetlifyImageProcessing
								? createProductionSrcSet(source, range, isMobile)
								: source
						}
						media={range.mediaQuery}
					/>
				);
			})
		}
		<img
			src={useNetlifyImageProcessing
				? createProductionImageSrc(
						sourceDesktop,
						screenRanges[screenRanges.length - 1],
						false
				  )
				: sourceDesktop}
			width={imgWidth}
			height={imgHeight}
			alt={alt || getAltFallback(name)}
			id={id}
			loading={aboveFold ? undefined : loading}
			data-zoomable={dataZoomable}
			data-zoom-src={dataZoomable ? sourceDesktop : undefined}
			class:list={[className, 'image-fade']}
			decoding="async"
			{...fetchPriority ? { fetchpriority: fetchPriority } : {}}
			onload="this.classList.add('loaded'); this.parentNode.parentNode.classList.add('image-loaded')"
		/>
	</picture>
</div>

<style>
	.picture-container {
		@apply relative block w-full;
	}

	/* Apply aspect ratio based on screen size */
	.picture-container::before {
		@apply block w-full content-[''];
	}

	/* Mobile aspect ratio */
	@media (max-width: 768px) {
		.picture-container::before {
			padding-top: calc(1 / var(--ratio-mobile) * 100%);
		}
	}

	/* Desktop aspect ratio */
	@media (min-width: 769px) {
		.picture-container::before {
			padding-top: calc(1 / var(--ratio-desktop) * 100%);
		}
	}

	.thumbhash {
		@apply absolute inset-0 z-0 bg-cover bg-center transition-opacity duration-300 ease-out;
	}

	.image-loaded .thumbhash {
		@apply opacity-0;
	}

	picture {
		@apply absolute left-0 top-0 block h-full w-full;
	}

	picture img {
		@apply block h-full w-full object-cover opacity-0 transition-opacity duration-300 ease-in;
	}

	picture img.loaded {
		@apply opacity-100;
	}
</style>
