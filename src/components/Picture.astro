---
/**
 * Picture Component
 *
 * A responsive image component that handles:
 * - Optimal image loading for different screen sizes
 * - Prevents layout shifts using aspect ratio
 * - Supports multiple image formats and resolutions
 *
 * @component
 * @example
 * ```astro
 * <Picture
 *   src="/images/example.jpg"          // Base image path
 *   urlFocus="/images/example-focus.jpg"    // Desktop focal point
 *   urlFocusMobile="/images/example-focus-mobile.jpg"  // Mobile focal point
 *   width={1200}                       // Original image width
 *   height={800}                       // Original image height
 *   name="example-image"               // Image name (used for alt text)
 *   ratioMobile="1/1"                  // Mobile aspect ratio
 *   ratioDesktop="16/9"                // Desktop aspect ratio
 *   span="6"                           // Grid columns to span
 *   thumbhash="data:image/png;base64,..." // Optional blur placeholder
 * />
 * ```
 */

import type { ImageProps } from '@types';
import { screens } from '@config/screens';
import { getAltFallback } from '@lib/helpers';

// --------------------------------------
// Types
// --------------------------------------
interface PictureProps extends ImageProps {
	urlFocus: string;
	urlFocusMobile: string;
	name: string;
	ratioMobile: string;
	ratioDesktop: string;
	span: string;
	position?: string;
	backgroundContainer?: 'container' | 'full';
	gridMarginDesktop?: number;
	gridMarginMobile?: number;
	gridGapDesktop?: number;
	gridGapMobile?: number;
	thumbhash?: string;
	dataZoomable?: boolean;
	dataZoomSrc?: string;
	aboveFold?: boolean;
	isFirstSlide?: boolean;
}

// --------------------------------------
// Configuration
// --------------------------------------
const CONFIG = {
	// Environment settings
	isProduction: import.meta.env.PROD,
	isNetlifyDev: Boolean(import.meta.env.NETLIFY_DEV),
	netlifyUrl: import.meta.env.NETLIFY_URL,

	// Layout constants
	scrollbarWidth: 17,
	maxContainerWidth: 1920,
	mobileBreakpoint: 'lg',
	gridMarginTotal: 2,

	// Grid defaults
	defaultGridMarginDesktop: 24,
	defaultGridMarginMobile: 16,
	defaultGridGapDesktop: 24,
	defaultGridGapMobile: 16,

	// Image optimization
	defaultImageQuality: 70,
	lowQualityPreview: 40,
	imageFormat: 'avif',
	fallbackFormat: 'webp',
	// Common device pixel ratios (1x, 2x, 3x)
	pixelRatios: [1, 2, 3],

	// Common widths for responsive images based on standard breakpoints
	// These widths ensure we're not generating too many or too few variants
	responsiveWidths: [360, 640, 768, 1024, 1280, 1440, 1920, 2560],
};

// Base URL for image processing
const baseUrl = CONFIG.isProduction
	? CONFIG.netlifyUrl
	: CONFIG.isNetlifyDev
	? 'http://localhost:8888'
	: CONFIG.netlifyUrl;

// Should we use Netlify Image processing?
const useNetlifyImageProcessing = CONFIG.isProduction || CONFIG.isNetlifyDev;

// --------------------------------------
// Process Screen Breakpoints
// --------------------------------------
const breakpoints = Object.entries(screens)
	.map(([key, value]) => ({
		key,
		value: parseInt(value.replace('px', '')),
	}))
	.sort((a, b) => a.value - b.value);

const screenRanges = breakpoints.map((breakpoint, index) => {
	const nextBreakpoint = breakpoints[index + 1];

	if (index === 0) {
		// First breakpoint (mobile)
		return {
			key: breakpoint.key,
			mediaQuery: `(max-width: ${breakpoint.value}px)`,
			maxWidth: breakpoint.value,
		};
	} else if (!nextBreakpoint) {
		// Last breakpoint (largest screens)
		return {
			key: breakpoint.key,
			mediaQuery: `(min-width: ${breakpoint.value + 1}px)`,
			maxWidth: breakpoint.value * 1.5, // Extra size for largest screens
		};
	} else {
		// Middle breakpoints
		return {
			key: breakpoint.key,
			mediaQuery: `(min-width: ${breakpoint.value + 1}px) and (max-width: ${
				nextBreakpoint.value
			}px)`,
			maxWidth: nextBreakpoint.value,
		};
	}
});

const mobileBreakpointIndex = breakpoints.findIndex(
	(bp) => bp.key === CONFIG.mobileBreakpoint
);

// --------------------------------------
// Component Props
// --------------------------------------
const {
	src,
	urlFocus,
	urlFocusMobile,
	width,
	height,
	name,
	ratioMobile,
	ratioDesktop,
	span,
	// Optional props with defaults
	alt,
	position = 'center',
	id,
	class: className,
	loading = 'lazy',
	backgroundContainer = 'container',
	gridMarginDesktop = CONFIG.defaultGridMarginDesktop,
	gridMarginMobile = CONFIG.defaultGridMarginMobile,
	gridGapDesktop = CONFIG.defaultGridGapDesktop,
	gridGapMobile = CONFIG.defaultGridGapMobile,
	// Optional features
	thumbhash,
	dataZoomable,
	aboveFold,
	isFirstSlide,
} = Astro.props;

// --------------------------------------
// Utility Functions
// --------------------------------------
const imageUtils = {
	validateProps() {
		if (
			!src ||
			!width ||
			!height ||
			!name ||
			!ratioMobile ||
			!ratioDesktop ||
			!span
		) {
			throw new Error('Missing required props in Picture component');
		}

		this.validateRatio(ratioMobile);
		this.validateRatio(ratioDesktop);
	},

	validateRatio(ratio: string) {
		if (ratio !== 'original' && !ratio.match(/^\d+\/\d+$/)) {
			throw new Error(
				`Invalid ratio format: ${ratio}. Must be either 'original' or 'number/number'`
			);
		}
	},

	getRatio(ratio: string, width: number, height: number): number {
		if (!ratio) {
			console.warn('Ratio is undefined, using default 1/1');
			return 1; // default square ratio
		}

		const [numerator, denominator] =
			ratio === 'original' ? [width, height] : ratio.split('/');
		return Number(numerator) / Number(denominator);
	},

	calculateColumnWidth(
		containerWidth: number,
		columns: number,
		gridGap: number
	): number {
		const totalGapSpace = gridGap * (columns - 1);
		const availableSpace = containerWidth - totalGapSpace;
		return availableSpace / columns;
	},

	calculateImageWidth(
		containerWidth: number,
		columns: number,
		span: string,
		gridGap: number
	): number {
		const columnWidth = this.calculateColumnWidth(
			containerWidth,
			columns,
			gridGap
		);
		return Math.round(
			columnWidth * Number(span) + gridGap * (Number(span) - 1)
		);
	},

	calculateImageHeight(imageWidth: number, ratio: number): number {
		return Math.round(imageWidth / ratio);
	},

	getContainerWidth(
		screenRange: (typeof screenRanges)[0],
		isMobile: boolean,
		gridMarginTotal: number
	) {
		let containerWidth = screenRange.maxWidth - CONFIG.scrollbarWidth;
		if (backgroundContainer === 'container' && !isMobile) {
			containerWidth =
				Math.min(containerWidth, CONFIG.maxContainerWidth) - gridMarginTotal;
		}
		return containerWidth;
	},

	// Find the nearest standard responsive width
	getNearestStandardWidth(width: number): number {
		return CONFIG.responsiveWidths.reduce((prev, curr) => {
			return Math.abs(curr - width) < Math.abs(prev - width) ? curr : prev;
		}, CONFIG.responsiveWidths[0]);
	},

	// Generate sizes attribute based on span and breakpoints
	generateSizesAttribute(span: string): string {
		const spanPercent = (Number(span) / 12) * 100;

		// For full-width spans, use viewport width
		if (spanPercent === 100) {
			return '100vw';
		}

		// For smaller spans, calculate more precise sizes based on breakpoints
		const mobileBreakpoint =
			breakpoints.find((bp) => bp.key === CONFIG.mobileBreakpoint)?.value ||
			1024;

		// For mobile, images often take more space proportionally
		return `(max-width: ${mobileBreakpoint}px) 100vw, ${spanPercent}vw`;
	},

	// Generate an array of appropriate widths for srcset
	generateResponsiveWidths(maxWidth: number): number[] {
		return CONFIG.responsiveWidths.filter((w) => w <= maxWidth * 2);
	},
};

// --------------------------------------
// Image URL Generation
// --------------------------------------
const imageProcessor = {
	createNetlifyImageUrl(
		source: string,
		width: number,
		height: number,
		quality = CONFIG.defaultImageQuality,
		format = CONFIG.imageFormat
	): string {
		return `${baseUrl}/.netlify/images?url=${source}&w=${width}&h=${height}&fit=cover&fm=${format}&q=${quality}`;
	},

	createProductionSrcSet(
		source: string,
		screenRange: (typeof screenRanges)[0],
		isMobile: boolean,
		gridMarginMobileTotal: number,
		gridMarginDesktopTotal: number,
		ratioMobileValue: number,
		ratioDesktopValue: number
	): string {
		const columns = isMobile ? 6 : 12;
		const gridGap = isMobile ? gridGapMobile : gridGapDesktop;
		const gridMargin = isMobile
			? gridMarginMobileTotal
			: gridMarginDesktopTotal;
		const containerWidth = imageUtils.getContainerWidth(
			screenRange,
			isMobile,
			gridMargin
		);
		const ratio = isMobile ? ratioMobileValue : ratioDesktopValue;

		// Calculate base image width - but ensure it never exceeds the actual screen width
		// This ensures we don't generate unnecessarily large images for small screens
		const baseWidth = Math.min(
			imageUtils.calculateImageWidth(containerWidth, columns, span, gridGap),
			screenRange.maxWidth
		);

		// For higher efficiency, use standard responsive widths
		const standardWidth = imageUtils.getNearestStandardWidth(baseWidth);

		// Generate device pixel ratio variants
		return CONFIG.pixelRatios
			.map((dpr) => {
				const imgWidth = Math.round(standardWidth * dpr);
				const imgHeight = imageUtils.calculateImageHeight(imgWidth, ratio);
				return `${this.createNetlifyImageUrl(
					source,
					imgWidth,
					imgHeight
				)} ${dpr}x`;
			})
			.join(', ');
	},

	createWidthBasedSrcSet(
		source: string,
		ratio: number,
		isMobile: boolean
	): string {
		// Get maximum possible width based on container and screen
		const lastScreenRange = screenRanges[screenRanges.length - 1];
		const maxScreenWidth = lastScreenRange.maxWidth;
		const columns = isMobile ? 6 : 12;
		const gridGap = isMobile ? gridGapMobile : gridGapDesktop;

		// Calculate maximum display width for the image
		const maxImageWidth = imageUtils.calculateImageWidth(
			maxScreenWidth,
			columns,
			span,
			gridGap
		);

		// Generate width options that make sense for this image
		const widths = imageUtils.generateResponsiveWidths(maxImageWidth);

		// Create a width-based srcset (Recommendation: use width descriptors for more flexibility)
		return widths
			.map((width) => {
				const height = imageUtils.calculateImageHeight(width, ratio);
				return `${this.createNetlifyImageUrl(source, width, height)} ${width}w`;
			})
			.join(', ');
	},

	createProductionImageSrc(
		source: string,
		screenRange: (typeof screenRanges)[0],
		isMobile: boolean,
		gridMarginMobileTotal: number,
		gridMarginDesktopTotal: number,
		ratioMobileValue: number,
		ratioDesktopValue: number
	): string {
		const columns = isMobile ? 6 : 12;
		const gridGap = isMobile ? gridGapMobile : gridGapDesktop;
		const gridMargin = isMobile
			? gridMarginMobileTotal
			: gridMarginDesktopTotal;
		const containerWidth = imageUtils.getContainerWidth(
			screenRange,
			isMobile,
			gridMargin
		);
		const ratio = isMobile ? ratioMobileValue : ratioDesktopValue;

		// For the fallback image source, use the exact viewport width to ensure proper sizing
		const width = Math.min(
			imageUtils.calculateImageWidth(containerWidth, columns, span, gridGap),
			screenRange.maxWidth
		);
		const height = imageUtils.calculateImageHeight(width, ratio);

		return this.createNetlifyImageUrl(source, width, height);
	},
};

// --------------------------------------
// Process Image Properties
// --------------------------------------
// Validate required props
imageUtils.validateProps();

// Process aspect ratios
const ratioDesktopValue = imageUtils.getRatio(ratioDesktop, width, height);
const ratioMobileValue = imageUtils.getRatio(ratioMobile, width, height);

// Determine image sources based on ratios
const sourceMobile = ratioMobile === 'original' ? src : urlFocusMobile;
const sourceDesktop = ratioDesktop === 'original' ? src : urlFocus;

// Calculate grid margins
const gridMarginDesktopTotal = gridMarginDesktop * CONFIG.gridMarginTotal;
const gridMarginMobileTotal = gridMarginMobile * CONFIG.gridMarginTotal;

// Determine fetch priority for performance
const fetchPriority = aboveFold
	? isFirstSlide || isFirstSlide === undefined
		? 'high'
		: 'low'
	: undefined;

// Use actual viewport width for the img tag
// Ensure we use the actual device width rather than the breakpoint value
const firstBreakpointKey = Object.keys(screens)[0];
const viewportWidth = Math.max(
	parseInt(screens[firstBreakpointKey].replace('px', '')),
	360 // Ensure we account for common mobile widths like 360, 375, etc.
);
const firstBreakpointScaledWidth = Math.round(viewportWidth);
const firstBreakpointScaledHeight = Math.round(
	viewportWidth / ratioMobileValue
);

// Generate sizes attribute for responsive loading
const sizesAttribute = imageUtils.generateSizesAttribute(span);
---

<div
	class="picture-container"
	style={`--ratio-mobile: ${ratioMobileValue}; --ratio-desktop: ${ratioDesktopValue};`}
>
	{
		thumbhash && (
			<div class="thumbhash" style={`background-image: url(${thumbhash});`} />
		)
	}
	<picture>
		{
			screenRanges.map((range, index) => {
				const isMobile = index < mobileBreakpointIndex;
				const source = isMobile ? sourceMobile : sourceDesktop;
				const ratio = isMobile ? ratioMobileValue : ratioDesktopValue;

				return useNetlifyImageProcessing ? (
					<source
						type={`image/${CONFIG.imageFormat}`}
						srcset={imageProcessor.createWidthBasedSrcSet(
							source,
							ratio,
							isMobile
						)}
						media={range.mediaQuery}
						sizes={sizesAttribute}
					/>
				) : (
					<source srcset={source} media={range.mediaQuery} />
				);
			})
		}

		{
			useNetlifyImageProcessing && (
				<source
					type={`image/${CONFIG.fallbackFormat}`}
					srcset={imageProcessor.createWidthBasedSrcSet(
						sourceMobile,
						ratioMobileValue,
						true
					)}
					sizes={sizesAttribute}
				/>
			)
		}

		<img
			src={useNetlifyImageProcessing
				? imageProcessor.createNetlifyImageUrl(
						sourceMobile,
						firstBreakpointScaledWidth,
						firstBreakpointScaledHeight
				  )
				: sourceMobile}
			width={firstBreakpointScaledWidth}
			height={firstBreakpointScaledHeight}
			alt={alt || getAltFallback(name)}
			id={id}
			loading={aboveFold ? undefined : loading}
			data-zoomable={dataZoomable}
			data-zoom-src={dataZoomable ? sourceDesktop : undefined}
			class:list={[className, 'image-fade']}
			decoding="async"
			{...fetchPriority ? { fetchpriority: fetchPriority } : {}}
			onload="this.classList.add('loaded'); this.parentNode.parentNode.classList.add('image-loaded')"
			sizes={sizesAttribute}
		/>
	</picture>
</div>

<style>
	.picture-container {
		@apply relative block w-full;
	}

	/* Apply aspect ratio based on screen size */
	.picture-container::before {
		@apply block w-full content-[''];
	}

	/* Mobile aspect ratio */
	@media (max-width: 768px) {
		.picture-container::before {
			padding-top: calc(1 / var(--ratio-mobile) * 100%);
		}
	}

	/* Desktop aspect ratio */
	@media (min-width: 769px) {
		.picture-container::before {
			padding-top: calc(1 / var(--ratio-desktop) * 100%);
		}
	}

	.thumbhash {
		@apply absolute inset-0 z-0 bg-cover bg-center transition-opacity duration-300 ease-out;
	}

	.image-loaded .thumbhash {
		@apply opacity-0;
	}

	picture {
		@apply absolute left-0 top-0 block h-full w-full;
	}

	picture img {
		@apply block h-full w-full object-cover opacity-0 transition-opacity duration-300 ease-in;
	}

	picture img.loaded {
		@apply opacity-100;
	}
</style>
