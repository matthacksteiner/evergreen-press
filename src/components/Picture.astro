---
/**
 * Picture Component
 *
 * Renders a responsive picture element with various image sizes and formats.
 * Supports both production (with image processing) and development environments.
 * Prevents layout shifts by maintaining proper aspect ratios before image loads.
 *
 * @component
 * @example
 * ```astro
 * <Picture
 *   src="/images/example.jpg"
 *   urlFocus="/images/example-focus.jpg"
 *   urlFocusMobile="/images/example-focus-mobile.jpg"
 *   width={1200}
 *   height={800}
 *   name="example-image"
 *   ratioMobile="1/1"
 *   ratioDesktop="16/9"
 *   span="6"
 *   thumbhash="data:image/png;base64,..."
 * />
 * ```
 *
 * Features:
 * - Responsive image loading with different sources for mobile and desktop
 * - Automatic size calculations based on grid system
 * - Optional thumbhash placeholder for improved loading experience
 * - Layout shift prevention using CSS aspect ratio
 * - Support for image zooming functionality
 *
 * The component preserves aspect ratios during loading to prevent CLS (Cumulative Layout Shift).
 * When thumbhash is provided, it displays a blurred placeholder until the image loads.
 */

import { screens } from '@config/screens';

const isProd = import.meta.env.PROD;
const netlifyDev = import.meta.env.NETLIFY_DEV;
const netlifyUrl = import.meta.env.NETLIFY_URL;

const scrollbarWidth = 17;
const scrollbarThreshold = 1920 + scrollbarWidth;

// Process screen sizes to create breakpoints
const breakpoints = Object.entries(screens)
	.map(([key, value]) => ({
		key,
		value: parseInt(value.replace('px', '')),
	}))
	.sort((a, b) => a.value - b.value);

// Create screen ranges for media queries
const screenRanges = breakpoints.map((breakpoint, index) => {
	const nextBreakpoint = breakpoints[index + 1];

	if (index === 0) {
		// First breakpoint (mobile)
		return {
			key: breakpoint.key,
			mediaQuery: `(max-width: ${breakpoint.value}px)`,
			maxWidth: breakpoint.value,
		};
	} else if (!nextBreakpoint) {
		// Last breakpoint (largest screens)
		return {
			key: breakpoint.key,
			mediaQuery: `(min-width: ${breakpoint.value + 1}px)`,
			maxWidth: breakpoint.value * 1.5, // Extra size for largest screens
		};
	} else {
		// Middle breakpoints
		return {
			key: breakpoint.key,
			mediaQuery: `(min-width: ${breakpoint.value + 1}px) and (max-width: ${
				nextBreakpoint.value
			}px)`,
			maxWidth: nextBreakpoint.value,
		};
	}
});

interface Props {
	// Required props
	src: string;
	urlFocus: string;
	urlFocusMobile: string;
	width: number;
	height: number;
	name: string;
	ratioMobile: string;
	ratioDesktop: string;
	span: string;

	// Optional props with defaults
	alt?: string;
	position?: string;
	id?: string;
	class?: string;
	loading?: 'eager' | 'lazy';
	backgroundContainer?: 'container' | 'full';
	gridMarginDesktop?: number;
	gridMarginMobile?: number;
	gridGapDesktop?: number;
	gridGapMobile?: number;

	// Optional features
	thumbhash?: string;
	dataZoomable?: boolean;
	dataZoomSrc?: string;
	aboveFold?: boolean;
	isFirstSlide?: boolean;
}

const {
	src,
	urlFocus,
	urlFocusMobile,
	width,
	height,
	name,
	ratioMobile,
	ratioDesktop,
	span,
	// Optional props with defaults
	alt,
	position = 'center',
	id,
	class: className,
	loading = 'lazy',
	backgroundContainer = 'container',
	gridMarginDesktop = 24,
	gridMarginMobile = 16,
	gridGapDesktop = 24,
	gridGapMobile = 16,
	// Optional features
	thumbhash,
	dataZoomable,
	aboveFold,
	isFirstSlide,
} = Astro.props;
// Input validation
if (
	!src ||
	!width ||
	!height ||
	!name ||
	!ratioMobile ||
	!ratioDesktop ||
	!span
) {
	throw new Error('Missing required props in Picture component');
}

// Determine fetchpriority based on aboveFold and isFirstSlide
// If it's above fold and it's the first slide, it gets high priority
// Only set fetchpriority when aboveFold is true
const fetchPriority = aboveFold
	? isFirstSlide || isFirstSlide === undefined
		? 'high'
		: 'low'
	: undefined;

const validateRatio = (ratio: string) => {
	if (ratio !== 'original' && !ratio.match(/^\d+\/\d+$/)) {
		throw new Error(
			`Invalid ratio format: ${ratio}. Must be either 'original' or 'number/number'`
		);
	}
};

validateRatio(ratioMobile);
validateRatio(ratioDesktop);

const baseUrl = isProd
	? netlifyUrl
	: netlifyDev
	? 'http://localhost:8888'
	: netlifyUrl;

const getRatio = (ratio: string, width: number, height: number): number => {
	if (!ratio) {
		console.warn('Ratio is undefined, using default 1/1');
		return 1; // default square ratio
	}

	const [numerator, denominator] =
		ratio === 'original' ? [width, height] : ratio.split('/');
	return Number(numerator) / Number(denominator);
};

const ratioDesktopValue = getRatio(ratioDesktop, width, height);
const ratioMobileValue = getRatio(ratioMobile, width, height);

const sourceMobile = ratioMobile === 'original' ? src : urlFocusMobile;
const sourceDesktop = ratioDesktop === 'original' ? src : urlFocus;

const gridMarginTotal = 2;
const gridMarginDesktopTotal = gridMarginDesktop * gridMarginTotal;
const gridMarginMobileTotal = gridMarginMobile * gridMarginTotal;

// Calculate column width accounting for grid gaps
const calculateColumnWidth = (
	containerWidth: number,
	columns: number,
	gridGap: number
): number => {
	const totalGapSpace = gridGap * (columns - 1);
	const availableSpace = containerWidth - totalGapSpace;
	return availableSpace / columns;
};

// Calculate total width for a span of columns including gaps
const calculateImageWidth = (
	containerWidth: number,
	columns: number,
	span: string,
	gridGap: number
): number => {
	const columnWidth = calculateColumnWidth(containerWidth, columns, gridGap);
	return Math.round(columnWidth * Number(span) + gridGap * (Number(span) - 1));
};

// Calculate image height based on width and aspect ratio
const calculateImageHeight = (imageWidth: number, ratio: number): number =>
	Math.round(imageWidth / ratio);

const altFallback = name
	? name
			.replace(/[-_]/g, ' ')
			.replace(/[^\w\s]/g, '')
			.replace(/\b\w/g, (char) => char.toUpperCase())
	: 'Image';

const generateSrcSet = (
	source: string,
	screenRange: (typeof screenRanges)[0],
	isMobile: boolean
): string => {
	// Determine container width based on screen size
	const columns = isMobile ? 6 : 12;
	const gridGap = isMobile ? gridGapMobile : gridGapDesktop;
	const gridMargin = isMobile ? gridMarginMobileTotal : gridMarginDesktopTotal;

	// Use different container widths based on screen range
	let containerWidth = screenRange.maxWidth - scrollbarWidth;

	if (backgroundContainer === 'container' && !isMobile) {
		// Adjust for container width
		const maxWidth = 1920;
		containerWidth = Math.min(containerWidth, maxWidth) - gridMargin;
	}

	// Calculate appropriate image dimensions
	const ratio = isMobile ? ratioMobileValue : ratioDesktopValue;

	return [1, 2, 3]
		.map((value) => {
			const width =
				calculateImageWidth(containerWidth, columns, span, gridGap) * value;
			const height = calculateImageHeight(width, ratio);
			return `${baseUrl}/.netlify/images?url=${source}&w=${width}&h=${height}&fit=cover&fm=avif&q=70 ${value}x`;
		})
		.join(', ');
};

const generateImgSrc = (
	source: string,
	screenRange: (typeof screenRanges)[0],
	isMobile: boolean
): string => {
	// Determine container width based on screen size
	const columns = isMobile ? 6 : 12;
	const gridGap = isMobile ? gridGapMobile : gridGapDesktop;
	const gridMargin = isMobile ? gridMarginMobileTotal : gridMarginDesktopTotal;

	// Use container width based on screen range
	let containerWidth = screenRange.maxWidth - scrollbarWidth;

	if (backgroundContainer === 'container' && !isMobile) {
		// Adjust for container width
		const maxWidth = 1920;
		containerWidth = Math.min(containerWidth, maxWidth) - gridMargin;
	}

	// Calculate appropriate image dimensions
	const ratio = isMobile ? ratioMobileValue : ratioDesktopValue;
	const width = calculateImageWidth(containerWidth, columns, span, gridGap);
	const height = calculateImageHeight(width, ratio);

	return `${baseUrl}/.netlify/images?url=${source}&w=${width}&h=${height}&fit=cover&fm=avif&q=70`;
};

// Calculate image width for render function
const getCalculatedWidth = () => {
	let containerWidth;
	const lastScreenRange = screenRanges[screenRanges.length - 1];

	if (backgroundContainer === 'container') {
		const maxWidth = 1920;
		// Always subtract scrollbar width
		containerWidth =
			Math.min(lastScreenRange.maxWidth, maxWidth) -
			scrollbarWidth -
			gridMarginDesktopTotal;
	} else {
		containerWidth = 2560 - scrollbarWidth;
	}

	return calculateImageWidth(containerWidth, 12, span, gridGapDesktop);
};

const imgWidth = getCalculatedWidth();
const imgHeight = calculateImageHeight(imgWidth, ratioDesktopValue);
---

{
	isProd || netlifyDev ? (
		<div
			class="picture-container"
			style={`--ratio-mobile: ${ratioMobileValue}; --ratio-desktop: ${ratioDesktopValue};`}
		>
			{thumbhash && (
				<div class="thumbhash" style={`background-image: url(${thumbhash});`} />
			)}
			<picture>
				{screenRanges.map((range, index) => {
					// Use mobile source for first breakpoint, desktop for others
					const source = index === 0 ? sourceMobile : sourceDesktop;
					const isMobile = index === 0;

					return (
						<source
							srcset={generateSrcSet(source, range, isMobile)}
							media={range.mediaQuery}
						/>
					);
				})}
				<img
					src={generateImgSrc(
						sourceDesktop,
						screenRanges[screenRanges.length - 1], // Use largest screen range
						false // Desktop
					)}
					width={imgWidth}
					height={imgHeight}
					alt={alt || altFallback}
					id={id}
					loading={aboveFold ? undefined : loading}
					data-zoomable={dataZoomable}
					data-zoom-src={dataZoomable ? sourceDesktop : undefined}
					class:list={[className]}
					decoding="async"
					{...(fetchPriority ? { fetchpriority: fetchPriority } : {})}
				/>
			</picture>
		</div>
	) : (
		<div
			class="picture-container"
			style={`--ratio-mobile: ${ratioMobileValue}; --ratio-desktop: ${ratioDesktopValue};`}
		>
			{thumbhash && (
				<div class="thumbhash" style={`background-image: url(${thumbhash});`} />
			)}
			<picture>
				{screenRanges.map((range, index) => {
					// Use mobile source for first breakpoint, desktop for others
					const source = index === 0 ? sourceMobile : sourceDesktop;

					return <source srcset={source} media={range.mediaQuery} />;
				})}
				<img
					src={sourceDesktop}
					width={imgWidth}
					height={imgHeight}
					alt={alt || altFallback}
					loading={aboveFold ? undefined : loading}
					id={id}
					data-zoomable={dataZoomable}
					data-zoom-src={dataZoomable ? sourceDesktop : undefined}
					class={className}
					decoding="async"
					{...(fetchPriority ? { fetchpriority: fetchPriority } : {})}
				/>
			</picture>
		</div>
	)
}

<style>
	.picture-container {
		@apply relative block w-full;
	}

	/* Apply aspect ratio based on screen size */
	.picture-container::before {
		@apply block w-full content-[''];
	}

	/* Mobile aspect ratio */
	@media (max-width: 768px) {
		.picture-container::before {
			padding-top: calc(1 / var(--ratio-mobile) * 100%);
		}
	}

	/* Desktop aspect ratio */
	@media (min-width: 769px) {
		.picture-container::before {
			padding-top: calc(1 / var(--ratio-desktop) * 100%);
		}
	}

	.thumbhash {
		@apply absolute inset-0 -z-10 bg-cover bg-center;
	}

	picture {
		@apply block;
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
	}

	picture img {
		@apply block h-full w-full object-cover;
	}
</style>
